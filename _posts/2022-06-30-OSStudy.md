# System Structure & Program Excution - 2

### PC ( program counter )
	- 실행 해야하는 명령어가 담긴 메모리를 가리키는 레지스터이다.
	- 현재 명령어가 실행 완료되면 다음 명령어가 담긴 메모리를 가리키게 됩니다.
	- CPU는 이 PC가 가리키는 명령어를 실행합니다.


### Synchronous I/O ( 동기식 입출력 )
- I/O 요청후 입출력이 완료 후 제어가 넘어감
- Synchronous I/O 구현법
	- I/O 작업이 끝날 때 까지 아무것도 안 하면서 CPU 낭비 시키는 구현 방법
	- I/O 처리를 기다리는 줄에 프로그램을 줄 세우고 CPU를 다른 프로그램에게 넘겨주는 방법

### Asynchronous I/O ( 비동기식 입출력 )
- I/O 요청후 제어가 즉시 넘어감

두 경우 모두 I/O의 완료는 인터럽트로 알려줌


### DMA (Direct Memory Access)
- 빠른입출력 장치가 인터럽트를 걸게 되면 너무 잦은 인터럽트가 걸리므로 중간에서 중재자 역할을 함


### I/O디바이스에 접근 하는 방법
- CPU의 명령중엔 메모리에만 접근하는 명령어(로드 스토어)가 있고 I/O(I/O 디바이스에도 각자 주소가 있는데)에 접근하는 명령어가 있음
- I/O 주소를 메모리 주소에 넣어두고 메모리 접근 하듯이 사용하는 Memory Mapped I/O가 있음


### 저장장치 계층 구조
- 주기억장치
	- 레지스터, 캐시, 메인메모리
	- 휘발성
	- CPU에서 직접 접근하며 실행가능
		- CPU가 접근 하려면 바이트 단위로 접근 할 수 있어야 함
	- 메인메모리에 접근 하려면 100배 정도의 속도차이가 있어서 CPU는 이 속도차이를 극복하기 위해 캐시메모리나 레지스터를 사용함 ( 이걸 캐싱이라고 함 )
	- 캐싱
		- 처음 읽을 땐 메모리에 접근해서 읽지만 두번째 같은 명령이 들어오면 그 때부턴 캐시메모리에서 읽어감 ( 메모리 접근에 비해 아주 빠름 )
		- 궁금한게 있는ㄷ ㅔ캐시메모리는 왜 빠른걸까? 
	
- 보조기억장치
	- 마그네틱 디스크 , 옵티컬 티스크 , 마그네틱 테이프
	- 비휘발성
	- CPU가 직접 접근 불가능함
		- 바이트 단위가 아닌 섹터 단위로 접근


### 프로그램의 실행 ( 메모리 LOAD )
프로그램이란건 파일 시스템에 파일 형태로 저장되어 있고 이걸 실행시키면 메모리에 올라가며 프로세스가 됩니다.
1. 프로그램을 실행 시키면 Virtual Memory(logical)에 Address space가 만들어지게 됩니다.
	- Address space : code-cpu가 실행할 기계어 코드,data-자료구조가 담김,stack-함수 호출및 리턴을 위한 공간
2. 이걸 물리적인 메모리(메인메모리)에 올리며 실행 시킵니다.
	-Physical Memory엔 커널영역이 있고 프로그램이 실행되며 당장 필요한 부분 ( 현재 실행중인 함수 )만 이곳에 올려둡니다.
	-로지컬 메모리인 Virtual Memory가 Physical Memory에 올라가려면 주소 변환 과정이 필요
3. Swap Area
	- ?


### 커널 주소 공간의 내용
- code
	- 시스템콜, 인터럽트 처리를 위한 코드
	- 자원관리를 위한 코드
- data
	- 프로세스를 관리하기 위한 자료구조 : PCB (Process Control Block)
- stack
	- 프로세스의 함수 호출과정을 쌓아두기 위한 자료구조
	- A가 시스템콜 쓰고 B도 시스템콜 쓰고 이걸 관리하기 위해 스택에 쌓는거임 ( 젤 아래꺼가 젤 오래된 명령이겠지? )

### 사용자 프로그램이 사용하는 함수
- 사용자 정의 함수
	- 프로그램에서 정의한 함수
- 라이브러리 함수
	- 남의 꺼 가져다 쓴 함수
	- 프로그램의 실행 파일들에 포함되어 있음
- 커널 함수
	- 운영체제의 함수
	- 이 함수 호출하는 행위 = 시스템콜





















---
title:  "[개발자 취업] 기술 면접에서 나올 수 있는 질문 리스트"

categories:
  - get-a-job
tags:
  - [get-a-job]

toc: true
toc_sticky: true

breadcrumbs: true

date: 2023-10-18
last_modified_at: 2023-10-18
---

# 기술 면접에서 질문할 수 있는 기술들
### Test
- 단위테스트
- kotest
- mockk
### Architecture
- hexagonal Architecture
- Layerd Architecture
### Java
- 해시 테이블과 맵 (Collection)
- 스레드
- JVM
### Spring
- 빈
- 디스패처 서블릿
- 프록시 
- 트랜잭션
### JPA
- 더티체크
- 영속성
- Lazy는 어떻게 동작해
- 엔티티 매니저는 어떻게 관리돼
- 프록시
- 트랜잭션
- query DSL 5.X 
### DB (MySQL로 준비하세요.. 🥲)
- DB 락
- DB 구조

-----
# 예상 질문 리스트

1. 단위 테스트와 모킹에 대해 
2. Kotest와 JUnit 사이의 주요 차이점은 무엇이며, Kotest를 사용함으로써 어떤 이점을 얻을 수 있는가? 
3. MockK를 사용하여 비동기 코드의 테스팅을 어떻게 수행하는가? 
4. 테스트 코드에서 코드 커버리지를 높이기 위한 전략 
5. 해시 테이블 대신 ConcurrentHashMap을 사용하는 이유와 ConcurrentHashMap의 동작 원리를 설명해보세요. 
6. 멀티스레드 환경에서 안전한 코드를 작성하기 위한 방법 중 어떤 동기화 기법이 있을까요? 
7. 멀티스레드 환경에서 데드락을 방지하고 해결하기 위한 방법 중 어떤 것을 사용했나요? 
8. JVM 옵션을 조정해본적 있나요? 
9. Java의 가비지 컬렉션(Garbage Collection) 동작 메커니즘에 대한 이해를 설명해주세요 
10. Spring IoC 컨테이너의 동작 원리와 스프링 빈 라이프사이클에 대해 
11. 디스패처 서블릿의 내부 동작과 필터(Interceptor)를 통해 수행하는 작업에 대해 
12. Spring AOP를 사용할 때 프록시 패턴의 장점과 한계에 대해 
13. Spring 트랜잭션 관리에서 분산 트랜잭션과 롤백에 대해 
14. Spring Framework의 캐시(Caching) 기능을 어떻게 활용하고, 어떤 상황에서 유용한지 설명해보세요 
15. Spring WebFlux와 Spring MVC의 차이점을 설명해주세요 
16. Spring Security를 사용하여 어떻게 인증과 권한 부여를 구현했는지 경험을 공유해주세요 
17. JPA에서 복합 키(Composite Key)를 다루는 방법 
18. 영속성 컨텍스트의 생명주기와 JPA 엔티티 상태(Transient, Persistent, Detached, Removed)에 대해 설명해주세요.
19. JPA의 엔티티매니저란?
20. JPA의 영속성 컨텍스트란? 
21. N+1 쿼리 문제를 해결하기 위한 방법 중 어떤 것을 사용했는지 경험을 공유해주세요. 
22. 엔티티 매니저의 동작과 플러시(Flush) 프로세스에 대해 설명해보세요 
23. 엔티티의 상속 관계와 매핑 전략에 대한 경험 
24. JPA에서의 데이터베이스 마이그레이션(Migration) 경험 
25. 데이터베이스 락의 종류와 각각의 사용 사례를 설명해보세요 
26. SELECT ... FOR SHARE와 SELECT ... FOR UPDATE의 차이를 설명하고 언제 사용해야 하는지 설명해주세요. 
27. 데이터베이스 성능 최적화를 위해 인덱스(Index)를 어떻게 설계하고 관리하는지 
28. 데이터베이스 복제(Replication) 및 샤딩(Sharding)에 대한 이해 
29. 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 이해와 설정 경험 
30. MySQL 스키마 디자인에서 성능 최적화를 위해 어떤 접근 방식을 사용했는지 경험을 공유해주세요 
31. Hexagonal architecture의 고급 사용 사례와 이점에 대해 언급해주세요 
32. ORM의 고급 기능(예: 엔티티 그래프, 비동기 쿼리 등)을 어떻게 활용했는지 경험을 공유해주세요. 
33. 백엔드 이외의 기술 영역에서 특별한 관심이나 경험 
34. 프로젝트 협업 경험 중 어려움을 극복한 사례와 그 과정에 대한 설명을 제공해주세요. 
35. 유지보수에 좋은 코드란


-----
# 내가 준비한 답변
**제 경험이 조금씩 첨가된 주관적인 답변이므로 참고만 하세요! 답이 아닙니다! 여러분의 의견을 존중합니다!**

### 단위 테스트와 모킹에 대해
단위 테스트는 S/W의 가장 작은 단위를 테스트하는 일이고 저는 Junit을 사용했던 경험이 있습니다. 
저는 이전 회사에서 처음으로 Junit을 사용한 개발자였습니다.
이전에도 개발 산출물에 단위테스트 폴더가 있었으나 아무런 산출물도 없고 아무도 행방을 모르고 있었습니다.
그러던 중에 제가 개발 스터디를 통해 TDD를 접하게 됐습니다.
매번 수동으로 was를 올리고 버튼을 눌러보고 터미널을 확인하지 않고도 테스트를 해볼 수 있다는 장점이 가장 크게 와닿아서 
혼자 Test code에 대해 공부하고 마침 회사에 작은 프로젝트(백오피스 개발) 하나를 맡게 되어 이에 junit4와 mockito를 사용했습니다.
누구도 해본적 없었고 저 또한 처음 해보는 일이어서 기술적인 어려움이 많았습니다.
혼자서 강의도 들어보고 스터디 멤버에게 물어보면서 진행했습니다.
현재 돌아보면 미숙한 코드이고 이는 앞으로 발전하면서 함께 개선하고자 합니다.

### Kotest와 JUnit 사이의 주요 차이점은 무엇이며, Kotest를 사용함으로써 어떤 이점을 얻을 수 있는가?
### MockK를 사용하여 비동기 코드의 테스팅을 어떻게 수행하는가?

### 테스트 코드에서 코드 커버리지를 높이기 위한 전략
코드커버리지는 테스트가 코드를 어느 정도를 "커버" 했는지를 말합니다. 즉, 테스트코드로 코드를 얼마나 완벽하게 테스트 할 수 있는가를 말하는데
크게 라인, 분기, 메소드가 있는걸로 압니다. 
메소드 단위로 테스트 코드를 짤 때 경계값을 주로 테스트 했습니다. 만약 메소드의 매개변수로 정수 0~100까지 받아야 한다면 -1,0,1,99,100,101 이런 값을 테스트합니다.
분기문 테스트, 예외가 던져지는 상황을 테스트했으며 외부서비스를 호출하는건 외부서비스에 의존적이기 때문에 이 부분은 격리해서 테스트 해야한다고 생각했고 
주로 repository를 분리해서 가짜객체를 만들고 이를 테스트했습니다.

### 멀티스레드 환경에서 안전한 코드를 작성하기 위한 방법 중 어떤 동기화 기법이 있을까요?
현업에서 데이터 정합성을 위해 알바를 고용해 데이터를 정합성을 맞출일이 있었고 이때 하루에 50명이 사용할 단기성 애플리케이션을 만드는 프로젝트가 있었습니다.
프로젝트를 진행하다 우연히 여럿이서 동시에 따닥하고 눌렀고 두개의 데이터가 동시에 들어와버렸습니다.

이게 여러번 있었고 동시성에 대해서 고민했는데 해결 못했는데..아..

스프링은 각 요청마다 스레드를 다르게 생성하고 , 각 스레드는 스택을 다 따로 쓰기 때문에 여러 스레드가 하나의 인스턴스를 참조합니다.
이게 바로 싱글톤 패턴으로 만들어진 서비스의 save()를 여러개의 쓰레드가 참조할 수 있는 이유
[참고한 내용](https://stackoverflow.com/questions/42091666/how-to-have-thread-safe-controller-in-spring-boot)

### 멀티스레드 환경에서 데드락을 방지하고 해결하기 위한 방법 중 어떤 것을 사용했나요?

### JVM 옵션을 조정해본적 있나요?
엑셀 다운로드 기능을 구현을 했는데 너무 많은 데이터 탓에 GC overhead limit exceeded 에러를 만났고
저는 로컬에서 메모리의 사용량을 늘려주도록 옵션을 조정했었습니다.
Java 7에서 있던 -XX:MaxPermSize=size, -XX:PermSize=size option들은 이제 Java 8에서는 Deprecated되었고 metaSpaceSize로 대체(superseded)되었다고 합니다.
```text
-XX:permSize=1024m
-Xms4096m
-Xmx6144m
-XX:MaxPermSize=6144m
```

### Java의 가비지 컬렉션(Garbage Collection) 동작 메커니즘에 대한 이해를 설명해주세요.
JVM의 Heap영역에서 사용하지 않는 객체를 삭제하는 일을 gc가 합니다.
GC는 Heap영역에서 GC Root(Stack영역, 메소드영역, Heap의 영역에 있는 다른 객체도 포함 등)가 닿을수 있는(참조된) 객체와 닿을 수 없는(참조가 없는) 객체를 탐색합니다.
이런 닿을 수 없는 객체가 수거 대상이고 Mark And Sweep 방식으로 수거합니다.
참조되는 객체는 Marking을하고 닿을 수 없는 객체는 Sweep을 합니다. 조각난 Heap의 메모리를 Compact로 모아줄 때도 있습니다.
Heap 자체가 Young과 Old Generation, metaspace로 나뉘어 있습니다. 
이중 young generation은 eden과 survivor0,1로 구성되었는데 에덴이 꽉차면 minor gc가 닿은 수 없는 객체를 survivor0으로 이동시키는데
0과 1은 하나는 꼭 비어있어야만 합니다. 살아남은 애들은 age가 올라갑니다. 또 에덴이 차고 minor gc가 다시 수거하고 살아남은 객체는 1로 이동합니다. 이때 또 객체의 age가 올라갑니다.
age 임계점이 있는데 이 임계점에 도달하면 old generation으로 이동합니다. old generation이 꽉 차면 major gc가 발생합니다.
이제 gc 발생 시마다 stop the world가 발생하는데 이게 gc 종류마다 시간이 좀 다릅니다.
지금까지 gc 종류로 크게 serial, parallel, g1, z 가 나왔는데 이중에 parallel이 8의 gc기 때문에 parallel은 young generation 에 일어나는 minor gc에 한해서 병렬수행합니다.
그러므로 stop the world 시간이 직렬 gc 보단 적습니다. 그러고 g1gc는 heap 영역을 young,old로 나누지 않고 region이란 영역으로 나누고 이중에 garbage 마크가 있는 영역만 수거해갑니다.

### 널널한 개발자의 강의를 보고 난 후의 가비지 컬렉터와 작동원리... 과연 그것을 물은 것일까? 영상을 보고..
JVM Heap Dump 분석 해봤어? 장애 대응 해봤어? 이걸 물은걸 수도 있다.
JVM Memory Leak에 대한 이야기를 봐야함.
서비스 지연 -> 장애 -> 대응해야함. 결국 시니어는 장애 상황에서 대응 할 줄 알아야 한다.

### Spring IoC 컨테이너의 동작 원리와 스프링 빈 라이프사이클에 대해
스프링 빈은 Spring ioc 컨테이너에 의해 관리되는 객체입니다. 싱글톤으로 생성되기 때문에 인스턴스가 오직 하나만 존재하고
빈을 등록하는 방법으론 @ComponentScan이 붙은 클래스가 있는 패키지 하위 패키지를 전부 스캔하면서 특정 애노테이션이 붙은 클래스를 빈으로 등록하는 방법이 있고 
java config에 등록하는 방법, xml에 등록 하는 방법등이 있습니다.
IoC는 제가 제어하는게 아니고 외부에서 관리를 해주기 때문에 제어권이 바뀌었다 해서 제어의 역전인데
Spring IoC 컨테이너는 빈 서로간의 의존성을 넣어주고 싱글톤 스코프의 빈을 제공하는게 주된 일입니다.
빈의 라이프 사이클엔 빈 생성, 의존관계 주입, 초기화 콜백 메소드, 소멸 전 콜백, 스프링 종료라는 사이클을 가지게 됩니다.
싱글톤 빈 : 디폴트
프로토타입 빈 : 매번 새로운 인스턴스를 생성하며, 각 요청 또는 의존성 주입 시마다 새로운 빈 인스턴스를 반환합니다.프로토타입 빈의 라이프사이클을 종료할 책임은 개발자에게 잇습니다.
요청, 세션, 글로벌, 스레드 등 다양한 빈 스코프가 있습니다.

### 디스패처 서블릿의 내부 동작과 필터(Interceptor)를 통해 수행하는 작업에 대해
사용자 로그인 필터를 개발하면서 디스패처 서블릿의 내부동작을 공부한 적이 있습니다.
서블릿 컨테이너가 웹에서 들어오는 Http 요청을 받아서 Servlet Requeest/response를 생성합니다.
디스패처 서블릿이 url을 분석해서 핸들러(컨트롤러)서블릿 인스턴스가 있는지 확인 후 없으면 init 메소드로 서블릿 컨테이너에 스레드를 생성하고
요청처리 로직을 실행합니다. 그러고 컨트롤러가 뷰리졸버를 통해 뷰를 제공하더나 json 객체를 클라이언트에게 응답을 제공합니다.

### Spring AOP를 사용할 때 프록시 패턴의 장점과 한계에 대해서
Aspect가 관점, 측면이란 뜻이고 Spring에서 관심사를 분리하기 위한 기술을 aop라고 합니다.
관심사의 분리를 통해 객체 지향을 지킬 수 있습니다.
저는 현업에서 사용해보진 못했지만 궁금해서 혼자 써본적은 있습니다.
EnableAspectJAutoProxy를 설정하고 Aspect 클래스라는 걸 작성해서  Before 어노테이션에 패키지 경로를 적으면
해당 패키지 하위의 모든 메소드가 호출되기 전에 아스펙트 로깅 메세지를 찍히는 걸 해본적이 있습니다.

### Spring 트랜잭션 관리에서 분산 트랜잭션과 롤백에 대해

### Spring Framework의 캐시(Caching) 기능을 어떻게 활용하고, 어떤 상황에서 유용한지 설명해보세요

### Spring WebFlux와 Spring MVC의 차이점을 설명해주세요

### Spring Security를 사용하여 어떻게 인증과 권한 부여를 구현했는지 경험을 공유해주세요 

-----

### 영속성 컨텍스트의 생명주기와 JPA 엔티티 상태(Transient, Persistent, Detached, Removed)에 대해 설명해주세요.
비영속(일시적인)상태는 JPA와 관련 없는 그냥 객체를 생성한 상태입니다.
해당 객체를 persist하거나 DB로부터 읽어오면 persistent 상태로 엔티티 매니저가 관리하는 대상이 됩니다. 
또한, 영속 엔티티는 영속성 컨텍스트에 저장되며, 이 컨텍스트 내에서 엔티티의 상태를 추적합니다.
준영속 상태는 영속성 컨텍스트와 더 이상 관련이 없는 상태입니다.
엔티티 매니저를 종료했거나, detach메소드를 실행하면 영속성 컨텍스트로부터 분리됩니다.
삭제는 엔티티에 Removed 표시를 해두고 엔티티 매니저 flush를 하면 쿼리가 실행되고 db에서 삭제됩니다.


객체를 생성하고 persist하거나 db로부터 find한 객체는 1차 캐시에 엔티티가 저장된 상태가 됩니다.
영속성 컨텍스트 내에서 엔티티를 찾거나 업데이트할 때 1차 캐시에서 해당 엔티티를 검색하게 됩니다.
이로써 JPA는 같은 데이터에 대해 같은 인스턴스를 제공하게 됩니다.

JPA는 트랜잭션을 커밋하기 전까진 쓰기지연 sql 저장소에 insert,update,delete등의 쿼리를 보관해두고 실행하지 않습니다.
트랜잭션이 커밋되면 엔티티 매니저가 영속성 컨텍스트를 FLUSH 하고 이때 저장소의 쿼리들이 db에서 실행됩니다.


### 엔티티 매니저의 동작과 플러시(Flush) 프로세스에 대해 설명해보세요
엔티티 매니저는 엔티티, 트랜잭션을 관리합니다.
엔티티 persist나 save.. 등등 crud들이 대부분 엔티티매니저를 통해 수행되고 트랜잭션 종료시 flush를 호출하는 역할도 합니다.
flush는 영속성 컨텍스트 내에서 변경된 엔티티를 데이터베이스에 반영하는 역할을 합니다.
트랜잭션을 커밋하거나 jpql을 실행하기 전에 호출이 됩니다.
insert, update, delete등 중요한 쿼리들이 수행되지만 대부분의 플러시가 자동으로 수행되기 때문에 잘 알아둬야 한다고 생각합니다.

### 엔티티의 상속 관계와 매핑 전략에 대한 경험
RDBMS엔 객체가 없기 때문에 엔티티의 상속관계를 DB에 구현하기 위한 전략들이 있습니다.
조인전략, 단일 테이블 전략, 클래스마다 테이블 전략이 있습니다.
단일 테이블로 했을시 Null이 들어가게 됩니다.
클래스마다 테이블전략은 중복 데이터가 들어가지만 자식 테이블에 모든 데이터가 있으므로 자식 엔티티 조회시엔 유리할 것이라고 생각됩니다.
조인전략은 부모와 자식을 다 따로 만들기 때문에 조인을 한번 거쳐야 합니다.
MappedSuperclass를 이용해 공통부분을 상속 받는 방법도 있습니다. 
공통 부분을 별도의 클래스로 분리할 수 있어서 좋지만 공통 엔티티에 변경이 일어나면 많은 엔티티를 업데이트 해야하는 경우도 있을 수 있습니다.

그러므로 무엇이 좋다라고 말씀 드리진 못하지만 팀의 스타일에 따르는게 맞을것 같습니다.

### JPA에서 복합 키(Composite Key)를 다루는 방법
IdClass를 이용한 방법과 EmbeddedId를 이용한 방법이 있습니다.
IdClass를 사용하면 어노테이션에 복합 키 클래스를 맵핑해야하고
EmbeddedId를 사용하면 필드로 복합 키 클래스를 맵핑합니다. 클래스 내에 복합 키 클래스를 포함하면 가독성이 좋을 것 같습니다.

### N+1 쿼리 문제를 해결하기 위한 방법 중 어떤 것을 사용했는지 경험을 공유해주세요.

### JPA에서의 데이터베이스 마이그레이션(Migration) 경험

### 데이터베이스 락의 종류와 각각의 사용 사례를 설명해보세요

### SELECT ... FOR SHARE와 SELECT ... FOR UPDATE의 차이를 설명하고 언제 사용해야 하는지 설명해주세요.

### 데이터베이스 성능 최적화를 위해 인덱스(Index)를 어떻게 설계하고 관리하는지

### 데이터베이스 복제(Replication) 및 샤딩(Sharding)에 대한 이해

### 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 이해와 설정 경험
REPEATABLE READ : 트랜잭션이 읽은 데이터에 대한 읽기 락을 설정하여, 다른 트랜잭션이 해당 데이터를 수정하지 못하도록 합니다. 
이로써 데이터의 일관성을 유지하며, 다른 트랜잭션과의 충돌을 방지합니다. 다른 트랜잭션에서의 동시 수정을 방지하므로 데드락(deadlock) 상황이 발생할 수 있습니다.

[트랜잭션 격리 수준 참고](https://velog.io/@yujiniii/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80)
### MySQL 스키마 디자인에서 성능 최적화를 위해 어떤 접근 방식을 사용했는지 경험을 공유해주세요

### Hexagonal architecture의 고급 사용 사례와 이점에 대해 언급해주세요

### ORM의 고급 기능(예: 엔티티 그래프, 비동기 쿼리 등)을 어떻게 활용했는지 경험을 공유해주세요.

### 백엔드 이외의 기술 영역에서 특별한 관심이나 경험

### 프로젝트 협업 경험 중 어려움을 극복한 사례와 그 과정에 대한 설명을 제공해주세요.

### 유지보수에 좋은 코드란
객체지향프로그래밍의 기본 규칙인 SOLID,
Single Responsibility
Open/close principle 
Liskov substitute
interface segregation 
dependency inversion 을 지켜야 한다고 생각합니다.

객체는 하나의 책임만 가져야 하고, 변경엔 닫히되 확장엔 열려있어야 하고, 하위 클래스는 상위 클래스를 대체 할 수 있어야 하며, 
인터페이스는 작게 분리되어야 하고 추상화 된 계층에 의존해야 합니다.
이 객체지향프로그래밍의 SOLID를 알려면 디자인패턴도 공부해야한다고 생각했습니다.
저는 혼자선 안되겠단 생각이 들었고 그래서 백기선의 디자인패턴 강의를 들었습니다.

또한 코드 세부적으론 가독성을 위해 팀원간의 코드 스타일을 맞추는 걸 지킵니다.

사실 개발을 하면서 문서화의 중요성도 느꼈습니다.
제가 했던 개발은 사전을 만들어야할 정도로 코드 데이터가 많았습니다.
또한 2000년 초부터 시작한 프로젝트여서 굉장한 레거시였고 서버에 알지 못할 프로젝트들도 많았습니다.
그걸 보면서 이 프로젝트들 다 죽은 프로젝트이지만 서버의 자원을 먹고 있고 분명 관리 되어야 한다는 생각이 들었습니다.
저 편하자고 하지 않으면 프로젝트의 히스토리를 모르고 무슨 단어인지 모르고 결국 제 뒷세대가 힘들다는걸 직접 배웠고 개발에 들인 시간만큼 문서작성에도 노력했습니다.

### 어떤 아키텍처를 선택하셨나요?
AccountController -> 
AccountService -> 
interface AccountRepository -> 
AccountDao implements AccountRepository -> 
AccountJpaRepository

인터페이스를 통해 비즈니스 로직과 데이터 액세스 작업의 분리를 했습니다. 
이렇게 했을시 비즈니스 로직 레이어가 데이터베이스 세부사항에 대해 알 필요가 없어집니다.
이렇게 알 필요가 없어졌을때 ORM의 손쉬운 교체와 Dao 클래스를 모의 객체(Mock)로 대체하여 테스트를 수행할 수 있습니다.

표현(Representation) 계층, 응용(Application) 계층, 도메인(Domain) 계층, 데이터 액세스(Infrastructure) 계층

### 도메인과 비즈니스
[도메인과 비즈니스에 대한 참고 블로그](https://velog.io/@eddy_song/domain-logic)


---
title:  "[Effective Java] ch1 - item8. finalizer와 cleaner사용을 피하라 "

categories:
  - effective-java
tags:
  - [effective-java]

toc: true
toc_sticky: true

breadcrumbs: true

date: 2024-01-04
last_modified_at: 2024-01-04
---

작성중

### 객체 소멸자 finalizer, cleaner를 사용하면 안되는 이유
이 두가지 객체 소멸자는 예측할 수 없으므로 deprecated된 api입니다.

접근할 수 없게 된 객체에 이 소멸자를 사용하더라도 이 소멸자가 얼마나 걸릴지 알 수 없습니다.
왜냐면 gc가 이 객체를 회수하는 일을 신속하게 하는지 내부 알고리즘에 달렸으며 gc마다 천차만별입니다.
즉, 제 시간에 소멸되는지 알 수 없습니다.

예를 들어 파일닫기에 이 소멸자를 사용한다면 시스템에서 동시에 오픈할 수 있는 한계가 있기 때문에 오류가 발생합니다.
책에서는 OutOfMemoryError를 내며 죽은 GUI 애플리케이션 디버깅 사례가 있는데 애플리케이션이 죽는 시점에 그래픽 수천개가 finalizer 대기열에서 회수를 기다리고 있었다고 합니다.
finalizer 스레드가 다른 애플리케이션보다 우선 순위가 낮아서 실행될 기회가 없었던 것입니다.

### finalizer 공격 1
아래처럼 `finalize` 호출시 본인을 다시 static 변수에 넣어줌으로써 gc를 피해갈 수 있습니다.
```
public class Zombie {

    static Zombie zombie;
    
    public void finalize() {
        zombie = this;
    }
}

```
중요한 건 아래처럼 생성자에 유효성 검사 로직도 회피한다는 것입니다.
```
public class Zombie2 {
    static Zombie2 zombie;
    int value;
    
    public Zombie2(int value) {
        if(value < 0) {
            throw new IllegalArgumentException("Negative Zombie2 value");
        }
        this.value = value;
    }
    
    public void finalize() {
        zombie = this;
    }
}
```




# System Structure & Program Excution - 1

컴퓨터 시스템에서 H/W가 어떻게 동작하는지
프로그램들이 H/W 위에서 어떻게 동작하는지 

H/W에 대한 설명을 담은 챕터

1. H/W
	- CPU
		- CPU는 MEMORY에서 하나씩 읽어서 실행
		- 매 클럭마다 메모리에서 인스트럭션을 하나 읽어서 실행하고 또 읽어서 실행하고
		- 레지스터 : 메모리보다 빠르지만 작은
		- 모드빗 (Mode Bit) : 운영체제인지 사용자 프로그램인지 구분해주는 것
			- 0 : 사용자 모드 ( 커널 모드 , 시스템 모드 ) : 운영체제가 CPU를 가지고 실행중 ( I/O 인터럽트가 들어오면 모드빗이 0으로 바뀌면서 CPU 제어권이 OS에게 넘어감)
			- 1 : 모니터 모드 ( 사용자 프로그램 ) : 사용자 프로그램이 CPU를 가지고 실행중 > 제한된 명령만 사용자가 실행 가능
		- 인터럽트 라인 : cpu는 항상 메모리에 있는 인스트럭션만 실행합니다 ( 하나를 실행하고 나면 다음에 실행할 인스트럭션의 주소값이 증가하고.. 무한반복)
						, 그럼 디스크에서 파일을 읽어오거나 쓰거나, 키보드의 값을 받거나.. 이런걸 cpu는 인터럽트 라인을 통해 받습니다!
		- CPU가 device controller에게 지시하고 CPU는 직접적으로 I/O 디바이스에 접근하지 않습니다.
	- MEMORY 
		- CPU의 작업공간

2. I/O
	- HARD DISK 
		- 보조기억장치이자 I/O장치
	- KEY BOARD ... 


3. Timer 
	- 정해진 시간이 흐르면 OS에게 제어권이 넘어가도록 함

4. DeviceController
	- I/O 장치를 관리하는 일종의 작은 CPU (H/W)
	- 제어 정보를 위한 제어레지스터, 상태 레지스터와 데이터 레지스터(Data Buffer)가 있음

5. DMA (Direct Memory Access)
	- 직접 메모리에 접근 할 수 있는 컨트롤러 
	- 메모리에 CPU도 접근하고 DMA도 접근합니다.
	- CPU와 DMA가 동시에 메모리에 접근하면 동시성 문제로 일관성이 깨지므로 누가 먼저 접근 했는지 조율하는 MEMORY CONTROLLER가 있습니다.
	- I/O 장치가 너무 인터럽트를 많이 거니까 (I/0의 결과물이 CPU에 들어올 때 인터럽트가 걸림) DMA가 대신 I/O의 결과물을 받고 그 결과물을 메모리에 복사까지 해두고 
	인터럽트들을 다 모아뒀다가 한번 인터럽트 겁니다.
	

6. System Call이란
	- 사용자 프로그램을 쭈욱- 실행하다가 I/O call이 발생하면 OS의 함수를 호출하는데 이를 System Call이라고 합니다.
	- 프로그램이 직접 인터럽트 라인을 실행하는 명령어를 실행합니다.
	- 프로그램이 os에게 요청하기 위해 cpu에게 인터럽트 라인을 실행중
	- modebit이 0으로 바뀌고 cpu의 제어권을 os가 가져감
	- 후에 device controller에게 i/o를 요청함
	- 트랩을 이용해서 인터럽트를 건다~!
	- os는 해당 프로그램이 파일에 권한이 있는지 등등 검사를 하고 요청함!
	- 해당 시스템 콜이 끝나면 디바이스 컨트롤러가 cpu에게 인터럽트를 거는데 이건 h/w인터럽트임 (즉, s/w인터럽트의 완료는 h/w인터럽트를 통해 완료됨)

7. Interrupt
	- Interrupt : H/W가 발생시킨 인터럽트
		- Timer 인터럽트, I/0 인터럽트
	- Trap : S/W가 발생시킨 인터럽트
		- Exception : 프로그램 오류
		- System Call : 프로그램이 커널 함수를 호출


## 인터럽트 
인터럽트의 종류마다 해야하는 일들이 다름

1. 인터럽트 벡터
	- 인터럽트 종류마다 어떤 함수를 실행 해야하는지 함수 주소를 갖다가 정의 해놓은 것을 인터럽트 벡터라고 함
2. 인터럽트 루틴
	- os의 코드에 인터럽트 종류마다 해야하는 일들이 정의되어 있음 이를 인터럽트 처리 루틴이라고 합니다.


























var store = [{
        "title": "Spring boot 1",
        "excerpt":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스 - 1일차   buildscript {     ext{         springBootVersion = '2.1.7.RELEASE'     }     repositories{         mavenCentral()         jcenter()     }     dependencies {         classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")     } }   ext  - build.gradle에서 사용하는 전역변수를 설정하겠다는 의미 - springBootVersion 전역변수를 생성하고 그 값을 '2.1.7.RELEASE'로 하겠다   repositories 중  ‘jcenter’ is deprecated   jcenter는 mavenCentral의 단점인 라이브러리 업로드의 복잡성을 개선한 저장소입니다. 하지만 지금은 보안 문제로 사용 X   repositories는 각종 의존성들을 어떤 원격 저장소에서 받을지 결정 mavenCentral()을 많이 사용   apply plugins: 'java' apply plugins: 'eclipse' apply plugins: 'org.springframework.boot' apply plugins: 'io.spring.dependency-management'   앞서 선언한 플러그인 의존성들을 적용할 것인지 결정하는 코드   apply plugins: 'io.spring.dependency-management'  이 플러그인은 스프링 부트의 의존성들을 관리해 주는 플러그인   dependencies {     implementation 'org.springframework.boot:spring-boot-starter-web'     testImplementation 'org.springframework.boot:spring-boot-starter-test' }  교재 상에선  compile 이라고 쓰여있지만 implementation으로   완성된 build.gradle   buildscript {     ext{         springBootVersion = '2.1.7.RELEASE'     }     repositories{         mavenCentral()         maven {             url \"https://plugins.gradle.org/m2/\"         } //        jcenter()     }     dependencies {         classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")     } }  plugins {     id 'java'     id 'eclipse'     id \"org.springframework.boot\" version \"2.7.0\"     id \"io.spring.dependency-management\" version \"1.0.11.RELEASE\" }  dependencies {     implementation 'org.springframework.boot:spring-boot-starter-web' //    implementation('org.springframework.boot:spring-boot-starter-websocket:2.6.7')     testImplementation 'org.springframework.boot:spring-boot-starter-test' }  group 'com.edu.book' version '1.0-SNAPSHOT'  repositories {     mavenCentral() }  dependencies {     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1' }  test {     useJUnitPlatform() }   git commit은 생략     ","categories": [],
        "tags": [],
        "url": "/Spring-Boot-1/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": " Intro ",
        "excerpt":"     Intro     안녕하세요!         History                          2022                         MONTH       WHAT DID I DO       💖                       January       IT기업 취업                         May       정보처리기사 취득                         December       SQLD 취득                     What can i do      JAVA   PostgreSql   Oracle   SpringFramework            Egov       Springboot          ","categories": [],
        "tags": [],
        "url": "/intro/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": "Spring boot 2",
        "excerpt":" SpringBoot의 시작점 만들기   Application.java  @SpringBootApplication public class Application {     public static void main(String[] args) {         SpringApplication.run(Application.class,args);     } }  @springBootApplication 의 기능  - 스프링 부트의 자동설정 - 스프링 Bean 읽기와 생성을 모두 자동으로 - 이 어노테이션이 있는 부분부터 설정을 읽음 \t- 고로 이 클래스는 항상 프로젝트 최상단에 위치해야함.   SpringApplicaion.run  - main에서 실행하는 이 메소드가 내장WAS를 실행합니다. \t- 내장WAS :  \t\t- WAS를 외부에 두지 않음 \t\t- 톰캣 설치 필요가 없어짐 \t\t- JAR 파일 실행     Hello.java  @RestController public class HelloController {      @GetMapping(\"/hello\")     public String hello(){         return \"hello\";     } }  @RestController  - 컨트롤러를 JSON을 반환하는 컨트롤러로 생성 #### @GetMapping - Get Method     JUnit 을 사용한 테스트 코드   테스트 코드 작성을 도와주는 프레임워크중 하나인  xUnit을 사용     JUnit 5부터는 @RunWith가 아닌 Extension이라는 일관된 방법을 통해 테스트를 실행하는 방법을 커스터 마이징 하는 것이다.  사용법은 @RunWith와 비슷하게 @ExtendWith라는 애노테이션을 사용해서 @ExtendWith(MyExtension.class)처럼  Extension 구현체를 지정 @ExtendWith 는 메타어노테이션으로 다른 어노테이션에 포함될 수 있는 어노테이션이므로 @ExtendWith 를 포함한 어떤 어노테이션이 설정되어 있다면 @ExtendWith 를 생략 할 수 있다.   ","categories": [],
        "tags": [],
        "url": "/Spring-Boot-2/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": "Java version",
        "excerpt":"Java Version  회사에서 JAVA Version에 대한 궁금증이 생겨서 쓰는 글입니다.   누구는 Java 8, Java 9, Java 10 .. 이렇게 쓰고   누군 JDK 1.8, JRE SE 7…   내가 JAVA의 버전에 대해서 잘 모른다고 생각이 들었고 이에 대해 공부해보고자 했습니다!     Java 8과 Java 11은   ","categories": [],
        "tags": [],
        "url": "/Java-Version/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": "Spring boot 3",
        "excerpt":"JUnit 을 사용한 테스트 코드   테스트 코드 작성을 도와주는 프레임워크중 하나인 xUnit을 사용   @WebMvcTest(controllers = HelloController.class) public class HelloControllerTest {      @Autowired     private MockMvc mvc;      @Test     public void ReturnHello() throws Exception {         String hello = \"hello\";         mvc.perform(                 get(\"/hello\"))                 .andExpect(status().isOk()) \t\t\t\t                 .andExpect(content().string(hello));     }  }    JUnit 5부터는 @RunWith가 아닌 Extension이라는 일관된 방법을 통해 테스트를 실행하는 방법을 커스터 마이징 하는 것이다.    사용법은 @RunWith와 비슷하게 @ExtendWith라는 애노테이션을 사용해서    @ExtendWith(MyExtension.class)처럼 Extension 구현체를 지정   @ExtendWith 는 메타어노테이션으로 다른 어노테이션에 포함될 수 있는 어노테이션이므로   @ExtendWith 를 포함한 어떤 어노테이션이 설정되어 있다면 @ExtendWith 를 생략 할 수 있다.        @WebMvcTest            Web(Spring MVC)에 집중할 수 있는 어노테이션 ( MVC를 위한 테스트 )       웹에서 테스트하기 힘든 컨트롤러를 테스트하는 데 적합.       웹상에서 요청과 응답에 대해 테스트할 수 있음.       시큐리티, 필터까지 자동으로 테스트하며, 수동으로 추가/삭제 가능.       Application Context 완전하게 Start 시키지 않고 web layer를 테스트 하고 싶을 때           org.springframework.test.web.servlet.MockMvc            웹 API 테스트시 이용       스프링 MVC 테스트의 시작점       이 클래스를 통해 HTTP GET, POST … 등 API 테스트           mvc.perform( get(\"/hello\") )            MockMvc를 통해 /hello 주소로 HTTP GET 요청       perform 메소드로 테스트 할 url을 설정       체이닝 지원       DispatcherServlet에 요청을 의뢰하는 역할을 한다.       MockMvcRequestBuilder클래스를 사용해 설정한 요청 데이터를 perform()의 인수로 전달한다.       get, post, put, delete, fileUpload 와 같은 메서드를 제공한다.       ResultActions 이라는 인터페이스를 반환한다.           class MockHttpServletRequestBuilder의 perform()            url이 요청할 데이터 설정.                    param / params                            요청 파라미터 설정                                   header / headers                            요청 해더 설정                                               DispatcherServlet에 요청을 의뢰하는 역할을 한다.       get, post, put, delete, fileUpload 와 같은 메서드를 제공한다.       ResultActions 이라는 인터페이스를 반환한다.           ResultActions 인터페이스            andDo()                    log(), print() 둘 중 하나만 인자로 받는 메서드           실행결과 출력 해줍니다.                            log() : 디버깅 레벨에서의 실행결과 출력               print() : MockHttpServletRequest, MockHttpServletResponse, Handler 등의 실행결과를 출력                                               andExpect()                    인자에 MockMvcResultMatchers에서 제공하는 ResultMatcher를 받는 메서드           HTTP 상태코드 등 굉장히 많은 ResultMatcher들이 있으니 사용할 때마다 확인 바람.                       andReturn()                    return 결과를 반환                           참고     체이닝 테스트 코드   public class ChainningTest {      @Test     public void testObjectSetter(){         TestPeaple peaple = new TestPeaple();         peaple.setAge(26).setHeight(168).setName(\"앵미\");     }  }  public class TestPeaple {     private int age;     private int height;     private String name;      public int getAge() {         return age;     }      public int getHeight() {         return height;     }      public String getName() {         return name;     }      public TestPeaple setAge(int age){         this.age = age;         return this;     }      public TestPeaple setHeight(int height){         this.height = height;         return this;     }      public TestPeaple setName(String name){         this.name = name;         return this;     } }   return으로 자신을 객체로 해서 돌려주면 체이닝 객체생성 할 수 있음     Test코드 작성하면서 사용한 라이브러리   JUnit5: 자바 단위 테스트를 위한 테스팅 프레임워크 AssertJ: 자바 테스트를 돕기 위해 다양한 문법을 지원하는 라이브러리     단위 테스트의 패턴      given/when/then 패턴 given-when-then 패턴이란 1개의 단위 테스트를 3가지 단계로 나누어 처리하는 패턴으로, 각각의 단계는 다음을 의미한다.   given(준비): 어떠한 데이터가 준비되었을 때 when(실행): 어떠한 함수를 실행하면 then(검증): 어떠한 결과가 나와야 한다.   ","categories": [],
        "tags": [],
        "url": "/Spring-Boot-3/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": "Lombok",
        "excerpt":"Lombok     Dto Class     @Getter @RequiredArgsConstructor public class HelloResponseDto {      private final String name;     private final int amount;  }          @Getter            게터 자동생성           @RequiredArgsConstructor            생성자 자동생성             Test Class   \t@Test     public void 롬복_기능_테스트(){         //given         String name = \"test\";         int amount = 1000; \t\t         //when         HelloResponseDto dto = new HelloResponseDto(name, amount); \t\t         //then         Assertions.assertThat(dto.getName()).isEqualTo(name);         Assertions.assertThat(dto.getAmount()).isEqualTo(amount); \t\t     }        Assertions.assertThat            assertEquals를 사용할 때 마다 expected와 actual의 위치에 대해서 헷갈릴 때가 많다.    assertThat을 사용해서 작성하면 그 의미를 더 분명히 할 수 있다.           isEqualTo            assertThat에 있는 값이랑 비교해서 같으면 성공.     dto에 값 넣어서 객체 생성 후 그 값이 셋팅할 때 넣은 변수랑 같으면 테스트 성공!             \t@Test     public void helloDto가_리턴된다() throws Exception {         String name = \"hello\";         int amount = 1000;         mvc.perform(                 get(\"/hello/dto\")                         .param(\"name\",name)                         .param(\"amount\", String.valueOf(amount)))                 .andExpect(status().isOk())                 .andExpect(jsonPath(\"$.name\",equalTo(name)))                 .andExpect(jsonPath(\"$.amount\",equalTo(amount)));     }      get(“/hello/dto”)            /hello/dtd 경로에 요청           “.param(“name”,name)            파라미터로 name:name을 보낸다.           andExpect   6월 12, 2022 9:42:34 오전 org.junit.platform.launcher.core.EngineDiscoveryOrchestrator lambda$logTestDescriptorExclusionReasons$7 INFO: 0 containers and 1 tests were Method or class mismatch  테스트 Method를 3개 작성하였는데 3개중 1개만 실행하였을 경우 위와 같은 Info Message 가 발생하니 TEST PASSED 뜨면 넘어가세요!    개인적으로 궁금해서 찾아보게 된   spring-boot-starter-test 라이브러리의 Hamcrest    hamcrest는 JUnit에 사용되는 Matcher 라이브러리    assertEquals(expedted, actual)이라는 코드보다 assertThat(expected, is(actual))라는 코드가 훨씬 보기 쉬울 것이다.   ","categories": [],
        "tags": [],
        "url": "/Lombok/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
        "title": "Toby spring",
        "excerpt":" 토비-스프링   초난감DAO           UserVO ```JAVA public class UserVO {   String id;   String name;   String password;       public String getId() {       return id;   }       public void setId(String id) {       this.id = id;   }       public String getName() {       return name;   }       public void setName(String name) {       this.name = name;   }       public String getPassword() {       return password;   }       public void setPassword(String password) {       this.password = password;   } }        - UserDAO ```JAVA  public class UserDAO {      public void add(UserVO user) throws SQLException {         String conn_url = \"jdbc:oracle:thin:@127.0.0.1:1521/xe\";         String conn_id = \"cho\";         String conn_pw = \"0000\";         Connection conn = DriverManager.getConnection(conn_url, conn_id, conn_pw);          PreparedStatement ps = conn.prepareStatement(\"insert into users2(id, name, password) values (?,?,?)\");         ps.setString(1,user.getId());         ps.setString(2,user.getName());         ps.setString(3,user.getPassword());          ps.executeUpdate();          ps.close();         conn.close();      }      public UserVO get(String id) throws SQLException {         String conn_url = \"jdbc:oracle:thin:@127.0.0.1:1521/xe\";         String conn_id = \"cho\";         String conn_pw = \"0000\";         Connection conn = DriverManager.getConnection(conn_url, conn_id, conn_pw);          UserVO user = new UserVO();         PreparedStatement ps = conn.prepareStatement(\"select * from users2 where id = ?\");         ps.setString(1,id);          ResultSet rs = ps.executeQuery();          rs.next();          user.setId(rs.getString(\"id\"));         user.setName(rs.getString(\"name\"));         user.setPassword(rs.getString(\"password\"));          rs.close();         ps.close();         conn.close();          return user;     }  }   public class Main {     public static void main(String[] args) throws SQLException {          UserDAO dao = new UserDAO();             UserVO user = new UserVO();          user.setId(\"testID1\");         user.setName(\"테스트1\");         user.setPassword(\"testPWD1\");          dao.add(user);          UserVO user2 = dao.get(\"testID1\");         System.out.println(\"ID : \" + user2.getId());         System.out.println(\"NAME : \" + user2.getName());         System.out.println(\"PASSWORD : \" + user2.getPassword());      } }   왜 초난감인가   변화에 민감한 코드다 객체지향은 미래의 변화를 대비해 설계하고 개발하는 방법인데 초난감 DAO의 경우 변화에 민감하다.   미래에 있을지도 모를 변화들을 가정해보자.     커넥션 정보가 변경 될 수도 있다.   쿼리가 변경 될 수도 있다.   DB가 변경 될 수도 있다. 등등 아주 많음   이에 대해 내가 고민해야할 것은  이 변화들이 일어날 때 필요한 작업을 최소화하면서 변화한 코드가 다른 곳에 어떻게 영향을 주지 않을 수 있을까?   이에 대한 해답은  관심사의 분리  커넥션정보에 대한 관심사의 분리, 쿼리 실행에 대한 관심사의 분리… 이렇게 분리해서 하나하나 클래스로 가지고 있게 된다면 변화가 생겼을때 최소한의 작업으로 다른 곳에 영향을 주지 않고 유지보수가 가능해진다. 또한 중복된 코드도 분리해주도록 하겠습니다.   그럼 UserDAO의 관심사를 보면      Connection에 대한 관심, Connection 정보의 중복   쿼리 실행에 대한 관심   Connection 오브젝트를 닫아주는 관심   public class UserDAO {      public void add(UserVO user) throws SQLException {          Connection conn = getConnection();          PreparedStatement ps = conn.prepareStatement(\"insert into users2(id, name, password) values (?,?,?)\");         ps.setString(1,user.getId());         ps.setString(2,user.getName());         ps.setString(3,user.getPassword());          ps.executeUpdate();          ps.close();         conn.close();      }      public UserVO get(String id) throws SQLException {          Connection conn = getConnection();          UserVO user = new UserVO();         PreparedStatement ps = conn.prepareStatement(\"select * from users2 where id = ?\");         ps.setString(1,id);          ResultSet rs = ps.executeQuery();          rs.next();          user.setId(rs.getString(\"id\"));         user.setName(rs.getString(\"name\"));         user.setPassword(rs.getString(\"password\"));          rs.close();         ps.close();         conn.close();          return user;     }      public Connection getConnection() throws SQLException {          String conn_url = \"jdbc:oracle:thin:@127.0.0.1:1521/xe\";         String conn_id = \"cho\";         String conn_pw = \"0000\";         Connection conn = DriverManager.getConnection(conn_url, conn_id, conn_pw);          return conn;     }  }  이렇게 Connection을 분리해서 변화에 대응은 했다.   만약 커넥션 정보에 대한 변화가 너무 많아진다면..? 가령 예를 들어 후에 100개의 기업들이 사용자관리를 위해 내가 만든 어플리케이션을 사갔고 100개의 기업들의 커넥션 정보가 다 다르다. 그럼 난… getConnection을 100개를 만들어야 하는가? 아니면 100개의 기업들에게 getConnection을 수정해서 쓰라고 해야하는가? 만약 getConnection이 나의 비밀무기라면?   어떻게 해야 UserDAO를 공개하지 않고 사용자가 db 커넥션 방식을 바꿀수있게 해줄 수 있는가   일단 내 생각     사용자에게 커넥션 정보를 받아서 그걸로 커넥션을 만들고 쿼리를 실행해준다!   메소드로 만들어둔 getConnection을 객체로 분리하고  객체로 분리한 connection 객체를 상속받은 클래스를 하나 만듦 (기업이름+conn 이런 식으로, 구현체 없이) 클래스를 만들어서  거기서 커넥션을 만들어서 돌려주도록 한다.   그럼 우선           커넥션 클래스 분리 ``` public class ConnectionManager {       public Connection getConnection() throws SQLException {        String conn_url = \"jdbc:oracle:thin:@127.0.0.1:1521/xe\";  String conn_id = \"cho\";  String conn_pw = \"0000\";  Connection conn = DriverManager.getConnection(conn_url, conn_id, conn_pw);   return conn;  }           }  2. DAO에서 Connection 해보기  public class UserDAO {   ConnectionManager connectionManager = new ConnectionManager();  public void add(UserVO user) throws SQLException {      Connection conn = connectionManager.getConnection();      PreparedStatement ps = conn.prepareStatement(\"insert into users2(id, name, password) values (?,?,?)\");     ps.setString(1,user.getId());     ps.setString(2,user.getName());     ps.setString(3,user.getPassword());      ps.executeUpdate();      ps.close();     conn.close();  }  public UserVO get(String id) throws SQLException {      Connection conn = connectionManager.getConnection();      UserVO user = new UserVO();     PreparedStatement ps = conn.prepareStatement(\"select * from users2 where id = ?\");     ps.setString(1,id);      ResultSet rs = ps.executeQuery();      rs.next();      user.setId(rs.getString(\"id\"));     user.setName(rs.getString(\"name\"));     user.setPassword(rs.getString(\"password\"));      rs.close();     ps.close();     conn.close();      return user; }   }   분리성공!  분리는 했으나 근본적인 문제는 해결되지 않았음 기업 100개의 커넥션 정보를 100개의 클래스파일로 만들어 줄 수는 없음!  나중에 추가 되거나 변경 되면 매번 클래스를 내가 변경해야하므로 기업이 추가 할 수 있도록 해줘야함 (dao는 내 비밀무기이므로 공개하지 않는 조건하에)  그럼 getConnection에 connection 정보를 기업이 생성 할 수 있도록 해야함  getConnection을 기업이 구현하도록 하면 됨 ConnectionManager를 추상클래스로 만들고 이를 기업이 상속받아서 구현토록 함   1. 인터페이스 생성  public interface ConnectionManager {   Connection getConnection() throws SQLException;   }   2. 인터페이스 상속 받은 클래스 생성  public class AConnection implements ConnectionManager{   @Override public Connection getConnection() throws SQLException {      String conn_url = \"jdbc:oracle:thin:@127.0.0.1:1521/xe\";     String conn_id = \"cho\";     String conn_pw = \"0000\";      Connection conn = DriverManager.getConnection(conn_url, conn_id, conn_pw);      return conn; } } ```      DAO 커넥션 변경     public class UserDAO {  private final ConnectionManager connectionManager;   public UserDAO(){      connectionManager = new AConnection(); //여기선 아직 AConnection이라는 구체적인 클래스명을 지시하고 있음  } \t  public void add(UserVO user) throws SQLException {       Connection conn = connectionManager.getConnection();      ...  } }           ” UserDAO에 팩토리 메소드 패턴을 적용해서 getConnection()을 분리합시다 “   ” 여러가지 단점이 많은 상속이라는 방법을 사용한다는 사실이 불편하다 “라고 합니다. 상속은 클래스끼리의 결합도를 낮추는 방법이 아닌것 같습니다! 부모 클래스의 변경이 있을시 자식 클래스에도 변화가 일어나고, 변화가 일어나지 않게 부모클래스를 막거나, 자식 클래스는 다른 클래스를 상속 받지 못하게 되는 여러가지 문제들이 있습니다.   어쨌든 DAO에 손도 안 대고 이제 커넥션을 변경 할 수 있을까요? 아니용 여기선 아직 AConnection이라는 구체적인 클래스명을 지시하고 있습니다. 생성자에서요! UserDAO의 모든 코드가 ConnectionManager 인터페이스를 제외한 어떤 클래스와도 관계를 갖지 못하게 하는 것이 목표입니다!   이 관심사는 UserDAO가 어떤 클래스의 객체를 이용할지를 결정하게 하는 관심사입니다..   이 관심사도 분리해야합니다 어떻게 분리할 것이냐면 UserDAO를 사용하는 클라이언트(제 3의 클라이언트)가 존재할 것입니다. 두개의 객체가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 것! 사용되는 객체는 서비스 사용하는 객체는 클라가 되고  UserDAO 서비스를 이용하는 클라이언트가 있는곳 ((제 3의 클라이언트)현재로선 main이 되겠음) 이 곳이 바로 UserDAO와 ConnectionManager 구현 클래스의 관계를 결정 해주는 기능을 분리하기 좋은 곳임   UserDAO 객체를 만들어서 사용하기 전에  UserDAO가 어떤 ConnectionManager의 구현체중 어떤걸 골라서 쓸 것인지 결정하도록 합시다. UserDAO오브젝트와 특정 클래스로부터 만들어진 ConnectionManager오브젝트 사이의 관계를 설정해줘야 한다. 클래스 사이의 관계 설정은 한 클래스가 인터페이스 없이 다른쪽 클래스를 사용한다는 뜻이므로 이번 같이 인터페이스가 낀 경우엔 오브젝트와 오브젝트 사이의 관계를 설정한다 라고 합니다.   오브젝트 사이이 관계는 런타임 시 한쪽이 다른쪽의 오브젝트의 레퍼런스를 갖고 있으면 됩니다. connectionManager = new AConnection(); 위 경우 AConnection의 레퍼런스를 UserDAO의 connectionManager에 넣음으로써 두 오브젝트가 사용이라는 관계를 맺게 합니다. 이 두 오브젝트 사이의 관계는 모델링시에 나오지 않고 런타임시 생기는 관계입니다. 바로 이런 런타임 오브젝트 관계를 만들어주는게 바로 클라이언트의 책임입니다.   클라이언트는 UserDAO를 사용하는 입장이므로 UserDAO의 세부적인 ConnectionManager의 구현 클래스를 선택하고(어떤게 ConnectionManager를 구현한지 알고 있어야 하므로 세부적이란 표현 사용) 선택한 구현 클래스의 오브젝트를 생성해서 UserDAO와 연결   기존의 UserDAO는 자신의 생성자에 자신이 구현 클래스의 오브젝트를 생성해서 문제가 발생.   오브젝트 사이의 관계가 만들어지려면 일단 만들어진 오브젝트가 있어야합니다. 오브젝트는 얼마든지 파라미터를 이용해 전달할 수 있으므로 외부에서 만들어준 것을 가져다가 쓰려고 합니다.   UserDAO에 파라미터의 타입을 인터페이스로 선언 해둔 생성자를 만들고 UserDAO의 생성자 호출 시 인터페이스의 구현체를 넘기기만 하면 됩니다.   그렇게 해서 바꾼 UserDAO(서비스)와 main(클라이언트)   UserDAO  \tprivate final ConnectionManager connectionManager;      public UserDAO(ConnectionManager connectionManager){         this.connectionManager = connectionManager;     }   main  UserDAO dao = new UserDAO(new AConnection());   이제 UserDAO는 자신의 관심사이자 책임인 SQL생성 및 실행에만 집중 할 수 있다 (토비는 이걸 또 분리하고 싶어 보이긴 한다) 더이상 DB생성 방법에 대해서 고민하지 않아도 ㅗ딘다.   이처럼 인터페이스를 넣고 클라이언트의 도움을 얻는 방법(생성자를 통한 구현체 셋팅)은 유연합니다.   지금까지 초난감DAO를 개선하면서 사용된 기술적 용어들     개방 폐쇄 원칙 ( Open Closed Principle )            클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.       UserDAO는 db connection이라는 기능 확장에 열려있다.       UserDAO의 핵심 기능인 SQL 수행에는 어떤 영향을 주지 않고도 얼마든지 Connection을 확장 할 수 있다.           객체 지향의 설계 원칙 ( SOLID )            Single Responsibility Principle : 단일 책임 원칙       Open Closed Principle : 개방 폐쇄 원칙       Liskov Subsitution Principle : 리스코프 치환 원칙       Interface Segregation Principle : 인터페이스 분리 원칙       Dependency Inversion Principle : 의존관계 역전 원칙           높은 응집도와 낮은 결합도            높은 응집도                    개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 원리로도 설명이 가능하다.           응집도가 높다 : 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻.           초난감DAO의 경우는 응집도가 많이 낮았습니다. db Connection기능과 SQL 수행하는 기능을 하고 있었기 때문입니다.           이 초난감DAO에서 ConnectionManager 클래스를 분리함으로써 응집도를 높였고 이에 대한 효과는                            변경이 필요한 부분을 찾는 일이 쉬워졌습니다. ( ConnectionManager의 구현체만 변경하면 됨 )               변경이 있더라도 다른 클래스의 수정을 요구하지 않습니다. ( ConnectionManager의 구현체만 변경하면 됨 )               변경한 기능이 UserDAO에 영향을 주지 않습니다.               테스트가 간편해졌습니다. ConnectionManager의 구현체만 테스트하면 됩니다.                                               낮은 결합도                    낮은 결합도는 관계를 유지하는 데 꼭 필요한 최소한의 방법으로 연결되는 것입니다.           초난감DAO에서는 UserDAO가 ConnectionManager의 구현체(AConnection)와 직접 관계를 갖지 않도록 하는 것이 낮은 결합도의 실천 방법이었습니다.                           전략패턴            main - UserDAO - ConnectionManager는 전략 패턴에 해당한다고 볼 수 있습니다.       전략 패턴은 인터페이스를 통해 구현체를 갈아끼우는 패턴이다! 이렇게 공부했었습니다.       중요한 점은 클라이언트의 역할입니다 ( 초난감DAO에서는 main이 되겟죠 )       UserDAO를 사용하는 main은 UserDAO가 사용할 전략을 UserDAO의 생성자를 통해 제공해줘야 합니다.       책에서는 UserDAO를 컨텍스트, main을 클라이언트, AConnection을 전략 이라고 설명했습니다!             IoC   현재의 초난감DAO엔 또 다른 문제가 있다  엉겁결에 main이 ConnectionManager의 구현체를 결정해주고 있는 것인데…   main은 그냥 main으로서 역할만 수행하면 되는데 지금 ConnectionManager의 구현체를 결정해주는 역할도 하고 있는 것이다. 이를 분리시키려고 한다.   이 기능을 분리시켜서 만들 오브젝트의 명칭은 팩토리이다. 팩토리 패턴과는 다르지만 이렇게 객체 생성 방법을 결정하고 그 오브젝트를 돌려주는 클래스를 팩토리 클래스라고 한다. 오브젝트를 생성하는 쪽과 오브젝트를 사용하는 쪽의 역할과 책임을 분리하는게 목적.   변경전  public static void main(String[] args) throws SQLException {      UserDAO dao = new UserDAO(new AConnection()); }   변경후  public static void main(String[] args) throws SQLException {          UserDAO dao = new DaoFactory().userDAO();  public class DaoFactory {     public UserDAO userDAO(){         ConnectionManager conn = new AConnection();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } }  이렇게 만들어진      UserDAO            핵심적인 데이터 로직           ConnectionManager            데이터 접근을 위한 기술 로직           DaoFactory            어플리케이션의 오브젝트 구성 및 그 관계를 정의       설계도 같은 역할       한 오브젝트가 어떤 오브젝트를 가져와 사용해야 하는지 정의해놓은 코드           이제 다른 기업에 UserDAO를 제공할 때 UserDAO, ConnectionManager, DaoFactory를 제공해야한다. UserDAO는 소스 제공하지 않지만 DaoFactory는 소스제공 합니다. 새로 만든 ConnectionManager 구현 클래스로 변경이 필요하면 DaoFactory를 수정하면 됩니다.   애플리케이션의 컴포넌트 역할을 하는 오브젝트(애플리케이션 요소들, UserDAO, ConnectionManager …)와 애플리케이션의 구조를 결정하는 오브젝트(DaoFactory)를 분리 했다는게 가장 의미가 있음.   근데 만약 userDAO가 아닌 다른 DAO를 생성하는 기능을 더 추가한다면?   public class DaoFactory {     public UserDAO userDAO(){         ConnectionManager conn = new AConnection();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } \tpublic AccountDAO accountDAO(){         ConnectionManager conn = new AConnection();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } \tpublic MessageDAO messageDAO(){         ConnectionManager conn = new AConnection();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } \t }  위와 같이 new AConnection을 하는 부분에 중복이 생성됩니다. 중복문제를 해결하기 위한 가장 좋은 방법은 분리해내는 것입니다.   public class DaoFactory {      public ConnectionManager connectionManager(){         return new AConnection();     }      public UserDAO userDAO(){         ConnectionManager conn = connectionManager();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } }  위와 같이 ConnectionManager를 생성하는 부분만 메소드로 분리하면 됩니다.   제어권의 이전을 통한 제어관계 역전   일반적으로 main()메소드와 같이 프로그램이 시작되는 지점에서 다음 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들러진 오브젝트에 있는 메소드 호출하는 등의 작업을 반복한다. 즉, 초난감DAO는 main에서 UserDAO 오브젝트를 직접 생성하고, 만들어진 오브젝트의 메소드를 사용한다. UserDAO 또한 ConnectionManager를 능동적으로 결정하고 필요할 때 쓴다. 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 정하고 스스로 관장하는 것, 사용하는 쪽이 제어하는 구조. 이걸 뒤집는 것이 IoC이다.   오브젝트가 오브젝트를 선택하는 것이 아니다. 오브젝트인 날 누가 어디서 부를지 모른다. 이것이 IoC이다.   나에 대한 제어 권한을 남에게 위임하는 것이다.   제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. UserDAO는 자신이 어떤 ConnectionManager 구현체를 만들고 사용할지 결정할 권한을 DaoFactory에게 넘겼으므로 UserDAO는 자신이 사용할 오브젝트를 스스로 선택하지 못하게 됨. UserDAO 자신도 DaoFactory에 의해 만들어짐. 또한 main 또한 DaoFactory가 만들어주고 공급해주는 ConnectionManager만을 사용하게 됨.   스프링의 IoC  현재 DaoFactory는 훌륭하게 IoC기능을 수행하고 있지만 이를 스프링이 할 수 있도록 만드려고 함.   스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 IoC가 적용된 오브젝트들을 빈팩토리라고 함. 즉, DaoFactory는 빈 팩토리 상태임 ( UserDAO와 ConnectionManager간의 관계 설정 및 생성까지 하는 오브젝트이므로 )   빈팩토리를 조금 더 확장한 애플리케이션 컨텍스트라는 것이 있는데 빈팩토리는 빈을 생성하고 관계를 설정하는 IoC의 기본 개념에 촛점을 맞춘 것이고  애플리케이션 컨텍스트는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이다. 현재는 DaoFactory 자체가 설정정보까지 담고 있는 IoC 엔진(스스로가 빈팩토리)이었다면 이걸 애플리케이션 컨텍스트의 설정정보로 사용되게끔 할 것이다. 그럼 DaoFactory의 IoC 작업은 애플리케이션 컨텍스트가 하게 될 거임.   ApplicationContext에 오브젝트를 올릴 설정파일 만들기     DaoFactory를 빈 팩토리가 사용할 수 있는 설정정보로 만듦. (어떤 클래스가 빈에 대한 설정 정보를 담았으며, 어떤 오브젝트를 설정할지의 정보를 담도록)   빈 팩토리를 통해 오브젝트를 가져와서 사용함.   @Configuration public class DaoFactory {      @Bean     public ConnectionManager connectionManager(){         return new AConnection();     }      @Bean     public UserDAO userDAO(){         ConnectionManager conn = connectionManager();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     } }      @Configuration            스프링에게 이 클래스가 빈 팩토리를 위한 오브젝트 설정을 담당하고 있음을 알려줌           @Bean            오브젝트를 만들어주는 메소드임을 알려줌           이렇게 ApplicationContext로부터 getBean으로 오브젝트를 가져올 수 있게 됩니다. 더이상 아래처럼 DaoFactory가 오브젝트를 생성하지 않아도 됩니다.  \tUserDAO dao = new DaoFactory().userDAO();   ApplicationContext로부터 오브젝트를 꺼내와서 사용하기  어떤 오브젝트를 ApplicationContext에서 사용할 것인지 설정하는 클래스를 만들었으니 ApplicationContext로부터 그 오브젝트를 꺼내서 사용해봅시다.   \tApplicationContext context = new AnnotationConfigApplicationContext(Main.class); \tUserDAO dao2 = context.getBean(\"userDAO\",UserDAO.class);   ApplicationContext의 동작방식  DaoFactory를 빈목록에 등록하고 userDAO를 요청하면 그 때 생성 요청하고 생성하고 사용합니다! 왜 ApplicationContext를 사용하냐면     구체적인 팩터리 클래스를 알 필요가 없어집니다.            UserDAO dao2 = context.getBean(\"userDAO\",UserDAO.class);       위처럼 어디서도 DaoFactory에 대한 정보가 없는데도 오브젝트를 잘 가지고 옵니다.           많은 IoC 관련 서비스를 제공합니다.   싱글톤 레지스트리와 오브젝트 스코프  ApplicationContext를 이용한 것과 DaoFactory를 직접 사용하는 것에 큰 차이점이 느껴지지 않습니다. 그저 userDao란 이름의 빈을 요청하면 아래 코드를 이용해 userDAO를 돌려주겠구나 생각한다.  \tㅇ@Bean     public UserDAO userDAO(){         ConnectionManager conn = connectionManager();         UserDAO userDAO = new UserDAO(conn);         return userDAO;     }   하지만 스프링의 ApplicationContext는 기존 오브젝트 팩토리와 차이점이 분명히 존재합니다. 오브젝트의 동일성과 동등성입니다. 값만 같은가 아니면 아예 같은 오브젝트인가.   아래 코드에서 dao1과 dao2는 서로 다른 오브젝트입니다.  DaoFactory daoFactory = new DaoFactory(); UserDAO dao1 = daoFactory.userDAO(); UserDAO dao2 = daoFactory.userDAO();   아래 코드는 dao1과 dao2가 완전히 동일한 오브젝트입니다.  ApplicationContext context = new AnnotationConfigApplicationContext(Main.class); UserDAO dao1 = context.getBean(\"userDAO\",UserDAO.class); UserDAO dao2 = context.getBean(\"userDAO\",UserDAO.class);   기존의 오브젝트 팩토리와는 확연히 다른 동작방법인것 같습니다. 스프링은 내가 100번을 요청해도 100번 다 같은 오브젝트를 돌려준다는 것입니다.   단순하게 getBean()을 할 때마다 userDao() 메소드를 호출하고 new에 의해 UserDAO가 생성되지 않는단 뜻입니다. 한번 오브젝트를 생성하고 이렇게 생성한 오브젝트를 재사용하는 방식을 싱글톤패턴이라고 합니다. 스프링은 기본적으로 빈 오브젝트를 모두 싱글톤으로 생성합니다. 디자인 패턴의 싱글톤과 비슷한 개념이지만 구현법이 틀립니다.   만약 UserDAO에 싱글톤패턴을 적용한다면..  public class UserDAO{ \t \tprivate static UserDAO INSTANCE; \tpprivate final ConnectionManager connectionManager; \t \tprivate UserDAO(ConnectionManager connectionManager){ \t\tthis.connectionManager = connectionManager; \t} \t \tpublic static synchronized UserDAO getInstance(){ \t\tif(INSTANCE == null) INSTANCE = new UserDAO( T-T..? ); \t\treturn INSTANCE; \t} \t }  위처럼 코드도 상당히 지저분해지고 private으로 만든 생성자는 외부에서 호출도 불가능해서 DaoFactory가 UserDAO를 생성해서 ConnectionManager를 넣어주는 것도 불가능해졌으며 싱글톤패턴은 오브젝트주입이 어려워 가짜 오브젝트를 넣어 테스트하는 것도 불가능합니다.   그렇다면 싱글톤패턴을 직접 구현하면 이렇게나 제약이 많은데 스프링은 왜 싱글톤으로 오브젝트를 만들까요? 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공합니다. 그것이 바로 싱글톤 레지스트리라고 하는겁니당! 싱글톤레지스트리는 private과 static으로 떡진 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하도록 합니다.   싱글톤과 오브젝트의 상태  싱글톤이 멀티스레드 환경에서 사용되는 경우엔 Stateless 상태로 만들어야 합니다. 상태정보를 내부에 가지고 있지 않은 상태를 말합니다.   멀티스레드 환경에서 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 일은 위험합니다. 저장된 오브젝트는 하나뿐이니 서로 값을 덮어씌우고 결과적으로 자신이 저장한 값이 아닌 것도 읽어오게 됩니다. 따라서 싱글톤은 Stateless하게 만듭니다.   그렇다면 Stateless방식으로 만든 클래스는 어떻게 정보를 다뤄야 할까요?? 파라미터, 로컬변수, 리턴 값등을 이용해서 독립된 공간을 갖는 장소에 오브젝트의 정보들을 옮겨놓으면 됩니다!   아래는 인스턴스 변수를 사용하도록 수정한 UserDAO입니다  public class UserDAO {      private final ConnectionManager connectionManager;     private Connection conn; //인스턴스 변수     private UserVO user; //인스턴스 변수      public UserDAO(ConnectionManager connectionManager){         this.connectionManager = connectionManager;     } \t \tpublic UserVO get(String id) throws SQLException {          Connection conn = connectionManager.getConnection();         this.user = new UserVO(); \t\t... \t} |   #DI ( 의존관계 주입 ) IoC와 DI ( 제어의 역전과 의존관계 주입 ) IoC의 핵심을 짚어주는, 좀 더 의도가 명확한 DI라는 단어를 쓴 것 뿐입니다. DI는 오브젝트의 레퍼런스를 외부로부터 제공 받고 이를 통해 다른 오브젝트와 의존관계가 만들어지는 걸 나타내는 단어입니다.   초난감DAO에서는 계속해서 UserDAO와 ConnectionManager간의 관계에 대해 설명하고 있는것 같습니다!   그렇다면 UserDAO에는 어떤 의존관계가 있는가?  UserDAO는 ConnectionManager의 getConnection을 꺼내와서 사용하는 의존관계가 있습니다. 다만 이것이 인터페이스로 연결이 되어서 약한 의존관계입니다. 강한 의존관계란 뭘까요? 결합도가 높은 상태입니다. ConnectionManager 인터페이스가 아닌 실제 구현체와 연결되어 ConnectionManager 내부의 변경에 예민하게 반응하게 되면 안됩니다. 이를 위해서 ConnectionManager를 인터페이스로 두고 AConnection을 구현한겁니다. 일종의 완충제라고 생각합니다!   런타임 의존관계?  사실 UserDAO는 ConnectionManager랑만 연결되어 있는것이 아닙니다! 런타임 오브젝트 사이에서 만들어지는 의존관계도 있습니다! 설계시 UserDAO가 런타임시 사용할 오브젝트가 어떤 클래스로 만들어진 것인지 미리 알 수 없습니다. 코드상엔 ConnectionManager만 보이니까요! 헌데 UserDAO가 만들어지고 나서 런타임시엔 실제 사용 대상인 오브젝트가 보입니다. 이를 의존오브젝트라고 합니다!   의존관계 주입의 핵심은 설계 시점에선 알지 못했던 두 오브젝트 ( UserDAO와 ConnectionManager ) 의 관계를 맺도록 도와주는 제 3의 존재 ( DaoFactory )가 있다는 겁니다! DI에서의 제 3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만든 오브젝트입니다.   DI에 대해서 정리를 해보자면      오브젝트의 레퍼런스를 외부로부터 제공 받고 이를 통해 다른 오브젝트와 의존관계가 만들어지는 것입니다.   런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정   런타임 시점의 의존관계를 갖기 위해선 인터페이스에만 의존하고 있어야 합니다.   의존관계 주입의 핵심은 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것 제 3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트입니다.   UserDAO의 DI  초난감DAO의 마지막 난관은 UserDAO 스스로가 사용할 구체적인 클래스가 무엇인지 알고 있다는 것이었습니다.  public UserDAO(){ \tconnectionManager = new AConnection(); }  위 코드에 따르면 UserDAO는 설계 시점에서 AConnection이라는 구체적인 클래스의 존재를 알고 있는 것입니다. 그래서 IoC의 방법을 사용해서 UserDAO로부터 런타임 의존관계를 드러내는 코드를 제거하고 제 3의 존재에게 관계설정의 책임을 분리한것입니다.   기능구현의 교환   ###기능교환 만약 회사에서 기능개발을 위한 로컬 DB 서버를 연결해두고 사용하다가 운영서버에 배치하기 위해 DB 커넥션 정보를 바꿔야 한다면 앞으로 DaoFactory의 이 부분만 바꾸면 됩니다.      @Bean     public ConnectionManager connectionManager(){         return new AConnection();     }   ###기능추가 DAO가 DB에 얼마나 많이 연결되어 사용되는지 파악하고 싶다면 DB 연결횟수 카운트하기 위해 DAO의 connectionManager() 메소드가 얼마나 생성되는 카운트해야 할까요? 그럼 카운트를 했다치고 작업이 완료되면 코드를 지울건가요? DAO 코드의 수정은 피해야하며, DB 연결횟수를 세는 것은 DAO의 관심사가 아닙니다. 어떻게는 분리해야합니다.   DI컨테이너는 이를 간단하게 해결합니다.   UserDAO와 ConnectionManager 사이에 연결횟수를 카운팅하는 오브젝트를 하나 더 추가합니다.   public class CountingConnectionManager implements ConnectionManager{  \tint count = 0; \tprivate ConnectionManager realConnectionManager;  \tpublic CountingConnectionManager(ConnectionManager realConnectionManager){ \t\tthis.realConnectionManager = realConnectionManager; \t}  \t@Override \tpublic Connection getConnection() throws SQLException { \t\tthis.count++; \t\treturn realConnectionManager.getConnection(); \t}  \tpublic int getCount(){ \t\treturn this.count; \t}  }  DaoFactory  \t@Bean     public ConnectionManager connectionManager(){         return new CountingConnectionManager(realConnectionManager());     }      @Bean     public ConnectionManager realConnectionManager(){         return new AConnection();     }  main  \tApplicationContext context = new AnnotationConfigApplicationContext(Main.class); \t//UserDAO dao = context.getBean(\"userDAO\",UserDAO.class);  \tCountingConnectionManager ccm = context.getBean(\"connectionManager\",CountingConnectionManager.class); \tSystem.out.println(ccm.getCount());  ","categories": [],
        "tags": [],
        "url": "/Toby-Spring/",
        "teaser": "/assets/images/blog_icon.jpg"
      },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/"
  },{
    "title": null,
    "excerpt":"var idx = lunr(function () {   this.field('title')   this.field('excerpt')   this.field('categories')   this.field('tags')   this.ref('id')    this.pipeline.remove(lunr.trimmer)    for (var item in store) {     this.add({       title: store[item].title,       excerpt: store[item].excerpt,       categories: store[item].categories,       tags: store[item].tags,       id: item     })   } });  $(document).ready(function() {   $('input#search').on('keyup', function () {     var resultdiv = $('#results');     var query = $(this).val().toLowerCase();     var result =       idx.query(function (q) {         query.split(lunr.tokenizer.separator).forEach(function (term) {           q.term(term, { boost: 100 })           if(query.lastIndexOf(\" \") != query.length-1){             q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })           }           if (term != \"\"){             q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })           }         })       });     resultdiv.empty();     resultdiv.prepend(''+result.length+' 개 결과 발견 ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-en.js"
  },{
    "title": null,
    "excerpt":"step1list = new Array(); step1list[\"ΦΑΓΙΑ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΟΥ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΩΝ\"] = \"ΦΑ\"; step1list[\"ΣΚΑΓΙΑ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΟΥ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΩΝ\"] = \"ΣΚΑ\"; step1list[\"ΟΛΟΓΙΟΥ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΑ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΩΝ\"] = \"ΟΛΟ\"; step1list[\"ΣΟΓΙΟΥ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΑ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΩΝ\"] = \"ΣΟ\"; step1list[\"ΤΑΤΟΓΙΑ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΟΥ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΩΝ\"] = \"ΤΑΤΟ\"; step1list[\"ΚΡΕΑΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΟΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΑ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΩΝ\"] = \"ΚΡΕ\"; step1list[\"ΠΕΡΑΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΟΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΑ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΩΝ\"] = \"ΠΕΡ\"; step1list[\"ΤΕΡΑΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΟΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΑ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΩΝ\"] = \"ΤΕΡ\"; step1list[\"ΦΩΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΟΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΑ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΩΝ\"] = \"ΦΩ\"; step1list[\"ΚΑΘΕΣΤΩΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΟΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΑ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΩΝ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΓΕΓΟΝΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΑ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΩΝ\"] = \"ΓΕΓΟΝ\";  v = \"[ΑΕΗΙΟΥΩ]\"; v2 = \"[ΑΕΗΙΟΩ]\"  function stemWord(w) {   var stem;   var suffix;   var firstch;   var origword = w;   test1 = new Boolean(true);    if(w.length '+result.length+' 개 결과 발견 ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-gr.js"
  },{
    "title": null,
    "excerpt":"var store = [   {%- for c in site.collections -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}     {%- assign docs = c.docs | where_exp:'doc','doc.search != false' -%}     {%- for doc in docs -%}       {%- if doc.header.teaser -%}         {%- capture teaser -%}{{ doc.header.teaser }}{%- endcapture -%}       {%- else -%}         {%- assign teaser = site.teaser -%}       {%- endif -%}       {         \"title\": {{ doc.title | jsonify }},         \"excerpt\":           {%- if site.search_full_content == true -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | jsonify }},           {%- else -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | truncatewords: 50 | jsonify }},           {%- endif -%}         \"categories\": {{ doc.categories | jsonify }},         \"tags\": {{ doc.tags | jsonify }},         \"url\": {{ doc.url | relative_url | jsonify }},         \"teaser\": {{ teaser | relative_url | jsonify }}       }{%- unless forloop.last and l -%},{%- endunless -%}     {%- endfor -%}   {%- endfor -%}{%- if site.lunr.search_within_pages -%},   {%- assign pages = site.pages | where_exp:'doc','doc.search != false' -%}   {%- for doc in pages -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}   {     \"title\": {{ doc.title | jsonify }},     \"excerpt\":         {%- if site.search_full_content == true -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | jsonify }},         {%- else -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | truncatewords: 50 | jsonify }},         {%- endif -%}       \"url\": {{ doc.url | absolute_url | jsonify }}   }{%- unless forloop.last and l -%},{%- endunless -%}   {%- endfor -%} {%- endif -%}] ","url": "http://localhost:4000/assets/js/lunr/lunr-store.js"
  },{
    "title": null,
    "excerpt":" {% if page.xsl %} {% endif %} {% assign collections = site.collections | where_exp:'collection','collection.output != false' %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:'doc','doc.sitemap != false' %}{% for doc in docs %} {{ doc.url | replace:'/index.html','/' | absolute_url | xml_escape }} {% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }} {% endif %} {% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:'doc','doc.sitemap != false' | where_exp:'doc','doc.url != \"/404.html\"' %}{% for page in pages %} {{ page.url | replace:'/index.html','/' | absolute_url | xml_escape }} {% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }} {% endif %} {% endfor %}{% assign static_files = page.static_files | where_exp:'page','page.sitemap != false' | where_exp:'page','page.name != \"404.html\"' %}{% for file in static_files %} {{ file.path | replace:'/index.html','/' | absolute_url | xml_escape }} {{ file.modified_time | date_to_xmlschema }}  {% endfor %} ","url": "http://localhost:4000/sitemap.xml"
  },{
    "title": null,
    "excerpt":"Sitemap: {{ \"sitemap.xml\" | absolute_url }} ","url": "http://localhost:4000/robots.txt"
  },{
    "title": null,
    "excerpt":"{% if page.xsl %}{% endif %}Jekyll{{ site.time | date_to_xmlschema }}{{ page.url | absolute_url | xml_escape }}{% assign title = site.title | default: site.name %}{% if page.collection != \"posts\" %}{% assign collection = page.collection | capitalize %}{% assign title = title | append: \" | \" | append: collection %}{% endif %}{% if page.category %}{% assign category = page.category | capitalize %}{% assign title = title | append: \" | \" | append: category %}{% endif %}{% if title %}{{ title | smartify | xml_escape }}{% endif %}{% if site.description %}{{ site.description | xml_escape }}{% endif %}{% if site.author %}{{ site.author.name | default: site.author | xml_escape }}{% if site.author.email %}{{ site.author.email | xml_escape }}{% endif %}{% if site.author.uri %}{{ site.author.uri | xml_escape }}{% endif %}{% endif %}{% if page.tags %}{% assign posts = site.tags[page.tags] %}{% else %}{% assign posts = site[page.collection] %}{% endif %}{% if page.category %}{% assign posts = posts | where: \"categories\", page.category %}{% endif %}{% unless site.show_drafts %}{% assign posts = posts | where_exp: \"post\", \"post.draft != true\" %}{% endunless %}{% assign posts = posts | sort: \"date\" | reverse %}{% assign posts_limit = site.feed.posts_limit | default: 10 %}{% for post in posts limit: posts_limit %}{% assign post_title = post.title | smartify | strip_html | normalize_whitespace | xml_escape %}{{ post_title }}{{ post.date | date_to_xmlschema }}{{ post.last_modified_at | default: post.date | date_to_xmlschema }}{{ post.id | absolute_url | xml_escape }}{% assign excerpt_only = post.feed.excerpt_only | default: site.feed.excerpt_only %}{% unless excerpt_only %}{% endunless %}{% assign post_author = post.author | default: post.authors[0] | default: site.author %}{% assign post_author = site.data.authors[post_author] | default: post_author %}{% assign post_author_email = post_author.email | default: nil %}{% assign post_author_uri = post_author.uri | default: nil %}{% assign post_author_name = post_author.name | default: post_author %}{{ post_author_name | default: \"\" | xml_escape }}{% if post_author_email %}{{ post_author_email | xml_escape }}{% endif %}{% if post_author_uri %}{{ post_author_uri | xml_escape }}{% endif %}{% if post.category %}{% elsif post.categories %}{% for category in post.categories %}{% endfor %}{% endif %}{% for tag in post.tags %}{% endfor %}{% assign post_summary = post.description | default: post.excerpt %}{% if post_summary and post_summary != empty %}{% endif %}{% assign post_image = post.image.path | default: post.image %}{% if post_image %}{% unless post_image contains \"://\" %}{% assign post_image = post_image | absolute_url %}{% endunless %}{% endif %}{% endfor %}","url": "http://localhost:4000/feed.xml"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page2/"
  }]
